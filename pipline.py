# -*- coding: utf-8 -*-
"""Pipline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o_3_cBM4FT0NtvwDY307JQe3xNawj0EB
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os

import statistics
!pip install nilearn
from nilearn.plotting.cm import cold_hot
from nilearn import datasets, plotting # Import datasets from nilearn
from nilearn.image import new_img_like # Import new_img_like from nilearn.image

#!git clone https://github.com/kdotdot/cerebra_atlas_python.git
!git clone https://github.com/marowakamalaldeen/Cerebra_aatlas_python.git
!pip install -r Cerebra_aatlas_python/requirements.txt
!pip install --editable Cerebra_aatlas_python/
!apt-get update
!apt-get install texlive texlive-latex-extra texlive-fonts-recommended dvipng cm-super -y --fix-missing

videodata1= np.load ("/content/drive/MyDrive/Data TU PHD DUBLIN/First data/video1_eLORETA.npy") #marowa's drive video1
videodata= np.load("/content/drive/MyDrive/Data TU PHD DUBLIN/First data/baseline_eLORETA.npy")  #base relax
videodata2= np.load ("/content/drive/MyDrive/Data TU PHD DUBLIN/First data/video2_eLORETA.npy") #video2
videodata3= np.load ("/content/drive/MyDrive/Data TU PHD DUBLIN/First data/video3_eLORETA.npy") #video3
# Load the source space atlas (mapping voxel data)
map_voxel = np.load("/content/drive/MyDrive/Data TU PHD DUBLIN/LABEL DETAILS/map_voxel.npy")
region_data = pd.read_csv("/content/drive/MyDrive/Data TU PHD DUBLIN/LABEL DETAILS/results_per_region (MY 101124).csv")
file_path = ('f"/content/drive/MyDrive/Data TU PHD DUBLIN/subjects Data/{subject_id}/evaluation/{video_type}_eLORETA.npy"')
#luca's drive
#pathLuca = "/content/drive/MyDrive/TU Dublin-NN/research/PHD CANDIDATES - AICL research LAB/CURRENT/Carlos Gomez Tapia - PB04482/dataset - full source activation space (31000x11250) for 35 subjects/"
#fileName = "video1_eLORETA.npy"
#videodata= np.load (pathLuca + fileName)
print(videodata1.shape)
print(len(videodata)) #len of points in brain (31553)
print(videodata[0])
print(len(videodata[0]))  #timestamps  (11250=125hz x 90 seconds)
print(type(videodata))
#video2data is a list of list (first list 31553 lenghth,each of this cell contains 11250 point,31553 is represented the number of the brain and the 11250 is the point in time  )

"""All Function"""

def load_subject_video_data(subject_id, video_type):
    """
    Load brain activation data for a given subject and video type.
    """
    file_path = f"/content/drive/MyDrive/Data TU PHD DUBLIN/subjects Data/{subject_id}/evaluation/{video_type}.npy"
    print(f"üîç Checking file path: {file_path}")  # Debugging print
    if not os.path.exists(file_path):
        print(f"‚ùå Warning: File not found for subject {subject_id}, video type {video_type}. Returning dummy data.")
        return np.random.randn(31335, 11250)  # Dummy fallback data
    return np.load(file_path)

def compute_rms_time_series1(videodata, map_voxel, region_data):
    """
    Compute the RMS for a given video dataset across all time locations,
    sorting 31,553 points into regions based on Cerebra ID,
    calculating RMS per time activation for each region,
    and visualizing them separately over time.
    """
    if "Cerebra_ID" not in region_data.columns or "Region_name" not in region_data.columns:
        raise ValueError("CSV file must contain 'Cerebra_ID' and 'Region_name' columns.")

    valid_cerebra_ids = set(region_data["Cerebra_ID"].unique())
    region_name_map = region_data.set_index("Cerebra_ID")["Region_name"].to_dict()

    avg_rms_time_series = {region: np.zeros(videodata.shape[1]) for region in valid_cerebra_ids}
    count_voxels = {region: np.zeros(videodata.shape[1]) for region in valid_cerebra_ids}

    for time_location in range(videodata.shape[1]):
        videodata_selected = videodata[:, time_location]
        voxel_rms = np.sqrt(videodata_selected**2)

        for region in valid_cerebra_ids:
            region_indices = np.where(map_voxel == region)[0]
            if len(region_indices) == 0:
                continue

            rms_values = voxel_rms[region_indices]
            avg_rms_time_series[region][time_location] += np.sum(rms_values)
            count_voxels[region][time_location] += len(rms_values)

    for region in valid_cerebra_ids:
        valid_indices = count_voxels[region] > 0
        avg_rms_time_series[region][valid_indices] /= count_voxels[region][valid_indices]

    return avg_rms_time_series, region_name_map

def plot_rms_time_series1(avg_rms_time_series, region_name_map, subject_id, video_type):
    """
    Visualize each region's RMS separately in 102 diagrams with both Region Name and Cerebra ID,
    and include Subject ID and Video Type in titles.
    """
    for region, rms_values in avg_rms_time_series.items():
        region_name = region_name_map.get(region, f"Region {region}")
        plt.figure(figsize=(10, 5))
        plt.plot(range(len(rms_values)), rms_values, label=f"{region_name} (ID: {region})")
        plt.xlabel("Time Activation (0 - 11250)")
        plt.ylabel("RMS Value")
        plt.title(f"{region_name} (ID: {region})\nSubject: {subject_id} | Video Type: {video_type}")
        plt.legend()
        plt.grid(axis="y", linestyle="--", alpha=0.6)
        plt.show()

def load_subject_video_data1():
    """
    Load brain activation data for a given subject and video type.
    Allows user to enter the file path manually.
    """
    file_path = input("Enter the full file path for the video data (.npy file): ").strip()

    if not os.path.exists(file_path):
        print(f"‚ùå Warning: File not found at {file_path}. Returning dummy data.")
        return np.random.randn(31335, 11250)  # Dummy fallback data

    # Check if the provided path is a directory. If so, list the .npy files within it.
    if os.path.isdir(file_path):
        npy_files = [f for f in os.listdir(file_path) if f.endswith(".npy")]
        if npy_files:
            print("Found the following .npy files in the directory:")
            for i, file in enumerate(npy_files):
                print(f"{i + 1}. {file}")
            file_index = int(input(f"Select the file to load (1-{len(npy_files)}): ")) - 1
            file_path = os.path.join(file_path, npy_files[file_index])
        else:
            print(f"‚ùå Error: No .npy files found in the directory {file_path}. Returning dummy data.")
            return np.random.randn(31335, 11250)

    return np.load(file_path)



def load_region_data1():
    """
    Load the region mapping data (CSV file) manually entered by the user.
    """
    csv_path = input("Enter the full file path for the region CSV file: ").strip()

    if not os.path.exists(csv_path):
        raise FileNotFoundError(f"‚ùå Error: CSV file not found at {csv_path}. Please check the path.")

    return pd.read_csv(csv_path)

def compute_rms_time_series2(videodata, map_voxel, region_data):
    """
    Sorts 31,553 points into regions based on Cerebra ID,
    Compute the RMS for a given video dataset across all time locations.
    calculating RMS per time activation for each region,
    and visualizing them separately over time.
    """
    required_columns = {"Cerebra_ID", "Region_name"}
    missing_columns = required_columns - set(region_data.columns)

    if missing_columns:
        raise ValueError(f"‚ùå CSV file must contain the following columns: {missing_columns}")

    valid_cerebra_ids = set(region_data["Cerebra_ID"].unique())
    region_name_map = region_data.set_index("Cerebra_ID")["Region_name"].to_dict()

    avg_rms_time_series = {region: np.zeros(videodata.shape[1]) for region in valid_cerebra_ids}
    count_voxels = {region: np.zeros(videodata.shape[1]) for region in valid_cerebra_ids}

    for time_location in range(videodata.shape[1]):
        videodata_selected = videodata[:, time_location]
        voxel_rms = np.sqrt(videodata_selected**2)

        for region in valid_cerebra_ids:
            region_indices = np.where(map_voxel == region)[0]
            if len(region_indices) == 0:
                continue

            rms_values = voxel_rms[region_indices]
            avg_rms_time_series[region][time_location] += np.sum(rms_values)
            count_voxels[region][time_location] += len(rms_values)

    for region in valid_cerebra_ids:
        valid_indices = count_voxels[region] > 0
        avg_rms_time_series[region][valid_indices] /= count_voxels[region][valid_indices]

    return avg_rms_time_series, region_name_map

def plot_rms_time_series2(avg_rms_time_series, region_name_map):
    """
    Visualize each region's RMS separately in 102 diagrams with both Region Name and Cerebra ID.
    """
    for region, rms_values in avg_rms_time_series.items():
        region_name = region_name_map.get(region, f"Region {region}")
        plt.figure(figsize=(10, 5))
        plt.plot(range(len(rms_values)), rms_values, label=f"{region_name} (ID: {region})")
        plt.xlabel("Time Activation (0 - 11250)")
        plt.ylabel("RMS Value")
        plt.title(f"{region_name} (ID: {region})")
        plt.legend()
        plt.grid(axis="y", linestyle="--", alpha=0.6)
        plt.show()




def load_video_data():
    """
    Manually enter the file path to load brain activation data.
    """
    file_path = input("Enter the full file path for the video data (.npy file): ").strip()
    if not os.path.exists(file_path):
        print(f"‚ùå Warning: File not found at {file_path}. Returning dummy data.")
        return np.random.randn(31335, 11250)  # Dummy fallback data
    return np.load(file_path)

def load_csv_data():
    """
    Manually enter the file path to load the CSV file.
    """
    file_path = input("Enter the full file path for the CSV file: ").strip()
    if not os.path.exists(file_path):
        print(f"‚ùå Warning: File not found at {file_path}. Please enter a valid path.")
        return None
    return pd.read_csv(file_path)


def compute_rms_time_series3(videodata, map_voxel, region_data):
    """
    Sort the voxels to their cortical regions and then compute the RMS for each region along
    all 11250 time activations. Next, sort each region to its corresponding MRT based on the CSV file,
    compute the average RMS per MRT, and prepare data for visualization.

    Parameters:
        videodata (np.ndarray): Brain activation data with shape (voxels, time).
        map_voxel (np.ndarray): 1D array mapping each voxel to a cortical region (Cerebra_ID).
        region_data (pd.DataFrame): DataFrame with region mapping data. Required columns are:
            'Cerebra_ID', 'Region_name', 'Multiple resource theory ID', 'MRT ID Name'

    Returns:
        avg_rms_per_mrt (dict): Dictionary mapping each MRT ID to its average RMS time series.
        mwl_index (np.ndarray): Overall index (sum of all MRT time series) over time.
        mrt_regions_map (dict): Mapping from MRT ID to list of region names.
        mrt_name_map (dict): Mapping from MRT ID to MRT ID Name.
    """
    # Check required columns.
    required_columns = {"Cerebra_ID", "Region_name", "Multiple resource theory ID", "MRT ID Name"}
    missing_columns = required_columns - set(region_data.columns)
    if missing_columns:
        raise ValueError(f"‚ùå CSV file must contain the following columns: {missing_columns}")

    # Create mapping dictionaries.
    valid_cerebra_ids = set(region_data["Cerebra_ID"].unique())
    region_name_map = region_data.set_index("Cerebra_ID")["Region_name"].to_dict()
    mrt_id_map = region_data.set_index("Cerebra_ID")["Multiple resource theory ID"].to_dict()
    mrt_name_map = region_data.set_index("Multiple resource theory ID")["MRT ID Name"].to_dict()

    # Build mapping from MRT to its constituent region names.
    mrt_regions_map = {}
    for cerebra_id, mrt_id in mrt_id_map.items():
        region_name = region_name_map.get(cerebra_id, f"Region {cerebra_id}")
        mrt_regions_map.setdefault(mrt_id, []).append(region_name)

    # Ensure the voxel mapping length matches the number of voxels in videodata.
    if len(map_voxel) != videodata.shape[0]:
        print(f"Warning: map_voxel length ({len(map_voxel)}) does not match videodata voxel count ({videodata.shape[0]}). Trimming map_voxel.")
        map_voxel = map_voxel[:videodata.shape[0]]

    # Compute RMS for each cortical region.
    rms_per_region = {}
    for region in valid_cerebra_ids:
        indices = np.where(map_voxel == region)[0]
        if len(indices) == 0:
            continue
        # Compute RMS across voxels at each time point.
        rms_per_region[region] = np.sqrt(np.mean(videodata[indices, :]**2, axis=0))

    # Group the regional RMS time series by MRT.
    rms_per_mrt = {}
    for region, rms_series in rms_per_region.items():
        mrt_id = mrt_id_map.get(region)
        if mrt_id is None:
            continue
        rms_per_mrt.setdefault(mrt_id, []).append(rms_series)

    # Compute the average RMS time series for each MRT.
    avg_rms_per_mrt = {mrt_id: np.mean(rms_list, axis=0) for mrt_id, rms_list in rms_per_mrt.items()}

    # Compute overall Mental Workload Index (MWL Index) as the sum over MRT time series.
    mwl_index = np.sum(list(avg_rms_per_mrt.values()), axis=0)

    return avg_rms_per_mrt, mwl_index, mrt_regions_map, mrt_name_map

def plot_rms_time_series3(avg_rms_per_mrt, mwl_index, mrt_regions_map, mrt_name_map):
    """
    Plot the average RMS time series for each MRT separately in red and overlay the overall
    average (Mental Workload Index) in green.
    """
    # Plot each MRT's average RMS time series in red.
    for mrt_id, rms_values in avg_rms_per_mrt.items():
        mrt_name = mrt_name_map.get(mrt_id, f"Unknown MRT {mrt_id}")
        regions_str = ", ".join(mrt_regions_map.get(mrt_id, []))
        plt.figure(figsize=(16, 5))
        plt.plot(range(len(rms_values)), rms_values, color='red', alpha=0.7,
                 label=f"{mrt_name} (MRT ID {mrt_id})")
        plt.xlabel("Time Activation (0 - 11250)", fontsize=12)
        plt.ylabel("Average RMS Value", fontsize=12)
        plt.title(f"Average RMS for {mrt_name} (MRT ID {mrt_id})\nRegions: {regions_str}", fontsize=14)
        plt.legend(loc='upper right', fontsize=10)
        plt.grid(axis="y", linestyle="--", alpha=0.6)
        plt.tight_layout()
        plt.show()

    # Plot overall MWL Index in green.
    plt.figure(figsize=(16, 5))
    plt.plot(range(len(mwl_index)), mwl_index, color='green', linewidth=2,
             label="Mental Workload Index")
    plt.xlabel("Time Activation (0 - 11250)", fontsize=12)
    plt.ylabel("Sum of Average RMS of Cortical Regions", fontsize=12)
    plt.title("Mental Workload Index", fontsize=14)
    plt.legend(loc='upper right', fontsize=10)
    plt.grid(axis="y", linestyle="--", alpha=0.6)
    plt.tight_layout()
    plt.show()

"""Subject Loop Cerebra ID Loop Time voxel activation Loop"""

#Subject Loop Cerebra ID Loop Time voxel activation Loop

# Validate required columns exist
if "Cerebra_ID" not in region_data.columns or "Region_name" not in region_data.columns:
    raise ValueError("CSV file must contain 'Cerebra_ID' and 'Region_name' columns.")

# Create mapping from Cerebra_ID to Region_name
mapping_region_id_to_name = region_data.set_index("Cerebra_ID")["Region_name"].to_dict()
# --------------------- Helper Functions ---------------------

def load_subject_video_data(subject_id, video_type):
    """
    Load brain activation data for a given subject and video type.

    Parameters:
        subject_id (str): Subject ID (e.g., 'NDARZY502FAG')
        video_type (str): Video type (e.g., "baseline", "video1", "video2", "video3")

    Returns:
        np.ndarray: Brain voxel activation data.
    """
    file_path = f"/content/drive/MyDrive/Data TU PHD DUBLIN/subjects Data/{subject_id}/evaluation/{video_type}_eLORETA.npy"
    return np.load(file_path)


def get_number_of_voxel_per_region(cerebra_id):
    """
    Get the number of voxels for a given cerebral region (Cerebra ID) and its region name.

    Parameters:
        cerebra_id (int): The ID of the cerebral region.

    Returns:
        tuple: (voxel_count (int), region_name (str))
    """
    voxel_count = np.sum(map_voxel == cerebra_id)  # Count occurrences of the Cerebra ID
    region_name = mapping_region_id_to_name.get(cerebra_id, "Unknown Region")
    return voxel_count, region_name


def plot_voxel_activation_for_region(time_location, cerebra_id, video_data):
    """
    Plot voxel activation histograms for the selected region and time location,
    for each video type in video_data.

    Parameters:
        time_location (int): The time index to analyze.
        cerebra_id (int): The Cerebra ID for the region of interest.
        video_data (dict): Dictionary of video datasets.
    """
    # Get indices for voxels in the desired region.
    region_indices = np.where(map_voxel == cerebra_id)[0]

    plt.figure(figsize=(12, 5))
    for video_label, data in video_data.items():
        # Restrict activation data to the region of interest and given time
        voxel_activation = data[region_indices, time_location]
        plt.hist(voxel_activation, bins=100, alpha=0.5, label=f"{video_label} - Time {time_location}")

    plt.title(f"Voxel Activation Distribution for Region {cerebra_id} at Time {time_location}")
    plt.xlabel("Voxel Activation Value")
    plt.ylabel("Frequency")
    plt.legend()
    plt.show()


def plot_number_of_voxel_per_region():
    """
    Plot a histogram showing the overall voxel counts per cortical region.
    """
    unique_regions = np.unique(map_voxel)
    plt.figure(figsize=(20, 5))
    plt.hist(map_voxel, bins=len(unique_regions), color="royalblue", alpha=0.7)
    plt.title("Number of Voxels per Cortical Region")
    plt.xlabel("Cortical Regions")
    plt.ylabel("Number of Voxels")
    plt.show()


# --------------------- Main Loop ---------------------

program_exit = False  # Flag to control overall program exit

while not program_exit:
    # ----- Outer Loop: Subject Selection -----
    subject_input = input("\nEnter Subject ID (or type 'exit' to quit): ").strip()
    if subject_input.lower() == "exit":
        program_exit = True
        break  # Exit the outer loop

    subject_id = subject_input  # Use the entered subject ID

    # Load video data for the subject
    try:
        video_data = {
            "Baseline": load_subject_video_data(subject_id, "baseline"),
            "Video1": load_subject_video_data(subject_id, "video1"),
            "Video2": load_subject_video_data(subject_id, "video2"),
            "Video3": load_subject_video_data(subject_id, "video3"),
        }
    except Exception as e:
        print(f"Error loading video data for subject {subject_id}: {e}")
        continue  # Ask for a new subject ID

    # Optionally, plot the overall voxel distribution per cortical region
    plot_number_of_voxel_per_region()

    # ----- Middle Loop: Cerebra ID Analysis -----
    while True:
        cerebra_input = input("\nEnter Cerebra ID (or type 'back' to choose another subject, or 'exit' to quit): ").strip()
        if cerebra_input.lower() == "back":
            print("Returning to subject selection.")
            break  # Return to the subject selection loop
        if cerebra_input.lower() == "exit":
            program_exit = True
            break  # Exit the middle loop, then outer loop

        try:
            cerebra_id = int(cerebra_input)
            voxel_count, region_name = get_number_of_voxel_per_region(cerebra_id)
            if voxel_count == 0:
                print(f"‚ö†Ô∏è Region '{region_name}' (ID: {cerebra_id}) has 0 voxels. Please try another Cerebra ID.")
                continue  # Remain in the Cerebra ID loop
            else:
                print(f"‚úÖ Selected Region: {region_name} (ID: {cerebra_id}) with {voxel_count} voxels.")
        except ValueError:
            print("‚ùå Invalid input. Please enter a valid Cerebra ID (an integer).")
            continue  # Remain in the Cerebra ID loop

        # ----- Inner Loop: Time Location Analysis -----
        while True:
            time_input = input("\nEnter a Time Location (or type 'back' to choose another Cerebra ID, or 'exit' to quit): ").strip()
            if time_input.lower() == "back":
                print("Returning to Cerebra ID selection.")
                break  # Break inner loop to re-enter a new Cerebra ID
            if time_input.lower() == "exit":
                program_exit = True
                break  # Break inner loop, then break out to end program

            try:
                time_location = int(time_input)
                # Validate time location using the Baseline video shape
                num_timestamps = video_data["Baseline"].shape[1]
                if time_location < 0 or time_location >= num_timestamps:
                    print(f"‚ö†Ô∏è Invalid Time Location. Please enter a value between 0 and {num_timestamps - 1}.")
                    continue

                # Plot voxel activation histograms for the selected region and time location
                plot_voxel_activation_for_region(time_location, cerebra_id, video_data)
            except ValueError:
                print("‚ùå Invalid input. Please enter a valid time location (integer).")

        if program_exit:
            break  # Break out of the Cerebra ID loop if user requested to exit

    if program_exit:
        break  # Break out of the subject loop if user requested to exit

# --------------------- End of Program ---------------------
print("\nThank you for using the program. Run ended.")

"""Details of each video per subject"""

def load_subject_video_data(subject_id, video_type):
    """
    Load brain activation data for a given subject and video type.
    Parameters:
        subject_id (str): Subject ID (e.g., 'NDARZY502FAG')
        video_type (str): Video type (e.g., "baseline", "video1", "video2", "video3")

    Returns:
        np.ndarray: Brain voxel activation data.
    """
    file_path = f"/content/drive/MyDrive/Data TU PHD DUBLIN/subjects Data/{subject_id}/evaluation/{video_type}_eLORETA.npy"
    return np.load(file_path)

def print_video_details(video, video_label):
    """
    Print details for a video dataset.

    Parameters:
        video (np.ndarray): The video data array.
        video_label (str): Label indicating which video (e.g., 'baseline', 'video1', etc.)
    """
    print(f"--- {video_label} ---")
    print("Number of brain points:", len(video))          # e.g., 31553 points
    print("First data point:", video[0])
    print("Number of timestamps in first point:", len(video[0]))  # e.g., 11250 timestamps
    print("Data type of video:", type(video))
    print()


# enter a subject ID manually
subject_id = input("Enter Subject ID (e.g., NDARZY502FAG): ").strip()

# List of video types to load for the subject
video_types = ["baseline", "video1", "video2", "video3"]

print(f"\n==== Details for Subject: {subject_id} ====")

# Loop over each video type, load the video, and print its details
for video_type in video_types:
    try:
        video = load_subject_video_data(subject_id, video_type)
        print_video_details(video, video_type.capitalize())
    except Exception as e:
        print(f"Error loading {video_type} for subject {subject_id}: {e}")
        print()

"""PIPLINE

‚úÖ Sort 31,553 points into regions based on Cerebra ID ‚úÖ Compute RMS per time activation for each region ‚úÖ Visualize each region's RMS separately and plot them
"""

# --------------------- Execution ---------------------
while True:
    subject_id = input("Enter Subject ID (or type 'exit' to quit): ").strip()
    if subject_id.lower() == "exit":
        break

    print("\nüîπ Step 1: Load Video Data üîπ")
    videodata = load_subject_video_data1()

    print("\nüîπ Step 2: Load Region Mapping Data (CSV) üîπ")
    region_data = load_region_data1()

    map_voxel = np.random.randint(1, 103, size=31335)  # Simulated voxel-to-region mapping

    try:
        avg_rms_time_series, region_name_map = compute_rms_time_series2(videodata, map_voxel, region_data)
        print("\n‚úÖ RMS Computation and Sorting Complete.")
        plot_rms_time_series2(avg_rms_time_series, region_name_map)
    except (KeyError, FileNotFoundError, ValueError) as e:
        print(f"‚ùå Error: {e}")

    print("\nüîÑ Execution completed. Restarting for a new subject.\n")

""" Sort the voxels to their cortical regions and then compute the RMS for each region along
    all 11250 time activations. Next, sort each region to its corresponding MRT based on the CSV file,
    compute the average RMS per MRT, and prepare data for visualization.
  ‚úÖ Sort 31,553 points into regions based on Cerebra ID ‚úÖ Compute RMS per time activation for each region, sort according to the cerebra id to the cube id (Multiple resource theory ID) calculate the region RMS' average and and connect the Region_name to MRT ID Name from csv file., I want to visualize as time series the MRT where the plot title has the name of all regions which is sorted to same the MRT
"""

def load_video_data():
    """
    Manually enter the file path to load brain activation video data (.npy file).
    Returns:
        np.ndarray: Loaded video data (if not found, dummy data is returned).
    """
    file_path = input("Enter the full file path for the video data (.npy file): ").strip()
    if not os.path.exists(file_path):
        print(f"‚ùå Warning: File not found at {file_path}. Returning dummy data.")
        return np.random.randn(31335, 11250)  # Dummy fallback data (voxels x time)
    return np.load(file_path)

def load_csv_data():
    """
    Manually enter the file path to load the region mapping CSV file.
    Returns:
        pd.DataFrame: Loaded CSV data, or None if file is not found.
    """
    file_path = input("Enter the full file path for the region CSV file: ").strip()
    if not os.path.exists(file_path):
        print(f"‚ùå Warning: File not found at {file_path}. Please enter a valid path.")
        return None
    return pd.read_csv(file_path)

def compute_rms_time_series3(videodata, map_voxel, region_data):
    """
    Sort the voxels to their cortical regions and then compute the RMS for each region along
    all 11250 time activations. Next, sort each region to its corresponding MRT based on the CSV file,
    compute the average RMS per MRT, and prepare data for visualization.

    Parameters:
        videodata (np.ndarray): Brain activation data with shape (voxels, time).
        map_voxel (np.ndarray): 1D array mapping each voxel to a cortical region (Cerebra_ID).
        region_data (pd.DataFrame): DataFrame with region mapping data. Required columns are:
            'Cerebra_ID', 'Region_name', 'Multiple resource theory ID', 'MRT ID Name'

    Returns:
        avg_rms_per_mrt (dict): Dictionary mapping each MRT ID to its average RMS time series.
        mwl_index (np.ndarray): Overall index (sum of all MRT time series) over time.
        mrt_regions_map (dict): Mapping from MRT ID to list of region names.
        mrt_name_map (dict): Mapping from MRT ID to MRT ID Name.
    """
    # Check required columns.
    required_columns = {"Cerebra_ID", "Region_name", "Multiple resource theory ID", "MRT ID Name"}
    missing_columns = required_columns - set(region_data.columns)
    if missing_columns:
        raise ValueError(f"‚ùå CSV file must contain the following columns: {missing_columns}")

    # Create mapping dictionaries.
    valid_cerebra_ids = set(region_data["Cerebra_ID"].unique())
    region_name_map = region_data.set_index("Cerebra_ID")["Region_name"].to_dict()
    mrt_id_map = region_data.set_index("Cerebra_ID")["Multiple resource theory ID"].to_dict()
    mrt_name_map = region_data.set_index("Multiple resource theory ID")["MRT ID Name"].to_dict()

    # Build mapping from MRT to its constituent region names.
    mrt_regions_map = {}
    for cerebra_id, mrt_id in mrt_id_map.items():
        region_name = region_name_map.get(cerebra_id, f"Region {cerebra_id}")
        mrt_regions_map.setdefault(mrt_id, []).append(region_name)

    # Ensure the voxel mapping length matches the number of voxels in videodata.
    if len(map_voxel) != videodata.shape[0]:
        print(f"Warning: map_voxel length ({len(map_voxel)}) does not match videodata voxel count ({videodata.shape[0]}). Trimming map_voxel.")
        map_voxel = map_voxel[:videodata.shape[0]]

    # Compute RMS for each cortical region.
    rms_per_region = {}
    for region in valid_cerebra_ids:
        indices = np.where(map_voxel == region)[0]
        if len(indices) == 0:
            continue
        # Compute RMS across voxels at each time point.
        rms_per_region[region] = np.sqrt(np.mean(videodata[indices, :]**2, axis=0))

    # Group the regional RMS time series by MRT.
    rms_per_mrt = {}
    for region, rms_series in rms_per_region.items():
        mrt_id = mrt_id_map.get(region)
        if mrt_id is None:
            continue
        rms_per_mrt.setdefault(mrt_id, []).append(rms_series)

    # Compute the average RMS time series for each MRT.
    avg_rms_per_mrt = {mrt_id: np.mean(rms_list, axis=0) for mrt_id, rms_list in rms_per_mrt.items()}

    # Compute overall Mental Workload Index (MWL Index) as the sum over MRT time series.
    mwl_index = np.sum(list(avg_rms_per_mrt.values()), axis=0)

    return avg_rms_per_mrt, mwl_index, mrt_regions_map, mrt_name_map

def plot_rms_time_series3(avg_rms_per_mrt, mwl_index, mrt_regions_map, mrt_name_map, subject_id, video_type):
    """
    Plot the average RMS time series for each MRT separately in red and overlay the overall
    average (Mental Workload Index) in green. The subject ID and video type are appended to the title.
    """
    # Plot each MRT's average RMS time series in red.
    for mrt_id, rms_values in avg_rms_per_mrt.items():
        mrt_name = mrt_name_map.get(mrt_id, f"Unknown MRT {mrt_id}")
        regions_str = ", ".join(mrt_regions_map.get(mrt_id, []))
        plt.figure(figsize=(16, 5))
        plt.plot(range(len(rms_values)), rms_values, color='red', alpha=0.7,
                 label=f"{mrt_name} (MRT ID {mrt_id})")
        plt.xlabel("Time Activation (0 - 11250)", fontsize=12)
        plt.ylabel("Average RMS Value", fontsize=12)
        # Append subject id and video type to the original title.
        plt.title(f"Average RMS for {mrt_name} (MRT ID {mrt_id})\nRegions: {regions_str}\nSubject: {subject_id} | Video: {video_type}", fontsize=14)
        plt.legend(loc='upper right', fontsize=10)
        plt.grid(axis="y", linestyle="--", alpha=0.6)
        plt.tight_layout()
        plt.show()

    # Compute overall average across all MRT time series.
    all_mrt_values = np.array(list(avg_rms_per_mrt.values()))
    overall_avg = np.mean(all_mrt_values, axis=0)

    # Plot the overall average RMS time series in green.
    plt.figure(figsize=(16, 5))
    plt.plot(range(len(overall_avg)), overall_avg, color='green', linewidth=2,
             label="Mental Workload Index")
    plt.xlabel("Time Activation (0 - 11250)", fontsize=12)
    plt.ylabel("Sum of Average RMS of Cortical Regions", fontsize=12)
    plt.title(f" Mental Workload Index\nSubject: {subject_id} | Video: {video_type}", fontsize=14)
    plt.legend(loc='upper right', fontsize=10)
    plt.grid(axis="y", linestyle="--", alpha=0.6)
    plt.tight_layout()
    plt.show()

# --------------------- Execution ---------------------
while True:
    # Load video data.
    videodata = load_video_data()
    # Load region mapping CSV.
    region_data = load_csv_data()
    if region_data is None:
        continue  # Retry if no valid CSV file was provided.

    # Simulated voxel-to-region mapping (ensure size matches videodata's voxel count).
    map_voxel = np.random.randint(1, 103, size=videodata.shape[0])

    subject_id = input("Enter the Subject ID: ").strip()
    video_type = input("Enter the Video Type: ").strip()

    try:
        avg_rms_per_mrt, mwl_index, mrt_regions_map, mrt_name_map = compute_rms_time_series3(videodata, map_voxel, region_data)
        print("RMS Computation and MRT Sorting Complete.")
        plot_rms_time_series3(avg_rms_per_mrt, mwl_index, mrt_regions_map, mrt_name_map, subject_id, video_type)
    except (KeyError, FileNotFoundError, ValueError) as e:
        print(f"‚ùå Error: {e}")

    cont = input("Do you want to process another dataset? (yes/no): ").strip().lower()
    if cont != 'yes':
        break

print("\nThank you for using the program. Run ended.")